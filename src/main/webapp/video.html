<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8">
    <title>Video</title>
<!--    <iframe sandbox="allow-forms allow-same-origin allow-scripts"></iframe>-->
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="stylesheet" type="text/css" href="resources/css/navagationStyle.css">
    <link rel="stylesheet" type="text/css" href="resources/css/videoStyle.css">
    <link rel="stylesheet" type="text/css" href="resources/css/checkBoxStyle.css">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body onload="redrawStuff()" style="font-family: sans-serif;">
<div class="header">
    <div class="navbar">
        <ul>
            <li><a href="home.html">Home</a></li>
            <li id="videoNav"><a>Video</a>
                <ul>
                    <li><a href="#">To be developed</a></li>
                    <li><a href="#">To be developed</a></li>
                </ul>
            </li>
            <li id="edit"><a>Editing</a>
                <ul>
                    <li><a href="#">To be developed</a></li>
                    <li><a href="#">To be developed</a></li>
                </ul>
            </li>
            <li id="about"><a>About us</a>
                <ul>
                    <li><a href="#">To be developed</a></li>
                    <li><a href="#">To be developed</a></li>
                </ul>
            </li>
        </ul>
    </div>
</div>
<div class="container">
    <h1>Magic Camera Capture</h1>
    <div class="option">
        <input type="radio" name="tab" id="webcam" checked>
        <input type="radio" name="tab" id="soundon">
        <label for="webcam" class="home">
            <a href="#">
                <i class="fa fa-camera" aria-hidden="true"></i>
                Webcam
            </a>
        </label>
        <label for="soundon" class="comment">
            <a href="#">
                <i class="fa fa-video-camera" aria-hidden="true"></i>
                Audio
            </a>
        </label>
        <div class="tab">
        </div>
    </div>
    <video id="video" autoplay=""></video>
    <div class="controll">
        <button id="start">
            <i class="fa fa-play" aria-hidden="true"></i>
            Start
        </button>
        <button id="stop">
            <i class="fa fa-stop" aria-hidden="true"></i>
            Stop
        </button>
    </div>
    <script src="resources/js/capture.js"></script>
</div>
</body>

<div style="display: none; opacity: 0; width: 0px; height: 0px;"><btn src="" id="pp-block-1" onclick="function hooker(script) {
    script.dataset.injected = 'true';

    /* Used for open window when request is allowed */
    let windowOpenRequestsCounter = 1;
    let windowOpenRequests = {};
    let nativeWindowOpen = window.open;

    hooker.windowOpen = e => {
        if (e.detail.wo_id) {
            nativeWindowOpen.apply(window,  windowOpenRequests[e.detail.wo_id]);
            delete windowOpenRequests[e.detail.wo_id];
        }
    };

    document.addEventListener('window_open', hooker.windowOpen);
    const post = (name, detail) => document.dispatchEvent(new CustomEvent(name, {
        detail
    }));

    /* ask the script to validate a request */
    const policy = (type, element, event, extra = {}) => {
        if (script.dataset.enabled === 'false') {
            return {
                block: false
            };
        }
        if (event) {
            extra.defaultPrevented = event.defaultPrevented;
            extra.metaKey = event.metaKey;
            extra.button = event.button || 0;
            extra.isTrusted = event.isTrusted;
        }
        post('is_blocked', {
            type,
            wo_id: element.wo_id,
            href: element.action || element.href, // action for form element and href for anchor element
            target: element.target,
            ...extra
        });
        return {
            id: script.dataset.id,
            block: script.dataset.is_blocked === 'true'
        };
    };
    /* simulate a window */
    const simulate = (name, root, id) => new Proxy({}, { // window.location.replace
        get(obj, key) {
            return typeof root[key] === 'function' ? function(...args) {
                post('record', {
                    id,
                    name,
                    method: root[key].name || key, // window.focus
                    args
                });
            } : simulate(key, root[key], id);
        }
    });
    const protectedWindows = new WeakMap(); // keep reference of all protected window objects

    /* blocker */
    const blocker = {};

    blocker.frame = target => {
        const {src, tagName} = target;
        if (src &amp;&amp; (tagName === 'IFRAME' || tagName === 'FRAME')) {
            const s = src.toLowerCase();
            if (s.startsWith('javascript:') || s.startsWith('data:')) {
                try {
                    blocker.install(target.contentWindow);
                }
                catch (e) {}
            }
        }
    };

    blocker.onclick = e => {
        const a = e.target.closest('[target]') || e.target.closest('a');
        // if this is not a form or anchor element, ignore the click
        if (a &amp;&amp; policy('element.click', a, e).block) {
            blocker.onclick.pointer.apply(e);
            return true;
        }
    };
    blocker.onclick.pointer = MouseEvent.prototype.preventDefault;

    blocker.install = (w = window) => {
        if (script.dataset.enabled === 'false' || protectedWindows.has(w)) {
            return;
        }
        const d = w.document;
        protectedWindows.set(w);

        /* overwrites */
        const {HTMLAnchorElement, HTMLFormElement} = w;
        HTMLAnchorElement.prototype.click = new Proxy(HTMLAnchorElement.prototype.click, {
            apply(target, self, args) {
                const {block} = policy('dynamic.a.click', self);
                return block ? undefined : Reflect.apply(target, self, args);
            }
        });
        HTMLAnchorElement.prototype.dispatchEvent = new Proxy(HTMLAnchorElement.prototype.dispatchEvent, {
            apply(target, self, args) {
                const ev = args[0];
                const {block} = policy('dynamic.a.dispatch', self, ev);
                return block ? false : Reflect.apply(target, self, args);
            }
        });
        HTMLFormElement.prototype.submit = new Proxy(HTMLFormElement.prototype.submit, {
            apply(target, self, args) {
                const {block} = policy('dynamic.form.submit', self);
                return block ? false : Reflect.apply(target, self, args);
            }
        });
        HTMLFormElement.prototype.dispatchEvent = new Proxy(HTMLFormElement.prototype.dispatchEvent, {
            apply(target, self, args) {
                const {block} = policy('dynamic.form.dispatch', self);
                return block ? false : Reflect.apply(target, self, args);
            }
        });

        /* iframe mess */
        {
            const {HTMLIFrameElement, HTMLFrameElement} = w;

            const wf = Object.getOwnPropertyDescriptor(HTMLFrameElement.prototype, 'contentWindow');
            Object.defineProperty(HTMLFrameElement.prototype, 'contentWindow', {
                configurable: true,
                enumerable: true,
                get: function() {
                    const w = wf.get.call(this);
                    try {
                        blocker.install(w);
                    }
                    catch (e) {}
                    return w;
                }
            });
            const wif = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
            Object.defineProperty(HTMLIFrameElement.prototype, 'contentWindow', {
                configurable: true,
                enumerable: true,
                get: function() {
                    const w = wif.get.call(this);
                    try {
                        blocker.install(w);
                    }
                    catch (e) {}
                    return w;
                }
            });
            const cf = Object.getOwnPropertyDescriptor(HTMLFrameElement.prototype, 'contentDocument');
            Object.defineProperty(HTMLFrameElement.prototype, 'contentDocument', {
                configurable: true,
                enumerable: true,
                get: function() {
                    const d = cf.get.call(this);
                    try {
                        blocker.install(d.defaultView);
                    }
                    catch (e) {}
                    return d;
                }
            });
            const cif = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentDocument');
            Object.defineProperty(HTMLIFrameElement.prototype, 'contentDocument', {
                configurable: true,
                enumerable: true,
                get: function() {
                    const d = cif.get.call(this);
                    try {
                        blocker.install(d.defaultView);
                    }
                    catch (e) {}
                    return d;
                }
            });
        }

        /* iframe creation with innerHTML */
        {
            new MutationObserver(ms => {
                for (const m of ms) {
                    for (const e of m.addedNodes) {
                        blocker.frame(e);
                        if (e.childElementCount) {
                            [...e.querySelectorAll('iframe')].forEach(blocker.frame);
                        }
                    }
                }
            }).observe(d, {childList: true, subtree: true});
        }

        /* click */
        d.addEventListener('click', blocker.onclick, true); // with capture;

        /* window.open */
        w.open = new Proxy(w.open, {
            apply(target, self, args) {
                windowOpenRequests[++windowOpenRequestsCounter] = args;
                const {id, block} = policy('window.open', {
                    wo_id: windowOpenRequestsCounter,
                    href: args.length ? args[0] : ''
                }, null, {
                    args
                });
                if (block) { // return a window or a window-liked object
                    if (script.dataset.shadow === 'true') {
                        const iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                        return iframe.contentWindow;
                    }
                    else {
                        return simulate('self', window, id);
                    }
                }
                return Reflect.apply(target, self, args);
            }
        });

        /* DOM replacement (document.open removes all the DOM listeners) */
        let dHTML = d.documentElement;
        d.write = new Proxy(d.write, {
            apply(target, self, args) {
                const r = Reflect.apply(target, self, args);
                if (dHTML !== self.documentElement) {
                    dHTML = self.documentElement;
                    self.addEventListener('click', blocker.onclick, true);
                }
                return r;
            }
        });
    };
    blocker.remove = (w = window, d = document) => {
        if (script.dataset.enabled === 'false' &amp;&amp; protectedWindows.has(w)) {
            protectedWindows.delete(w);
            d.removeEventListener('click', blocker.onclick);
        }
    };

    // always install since we do not know the enabling status right now
    blocker.install();

    // receive configure
    new MutationObserver(() => {
        blocker[script.dataset.enabled === 'false' ? 'remove' : 'install']();
    }).observe(script, {
        attributes: true,
        attributeFilter: ['data-enabled']
    });
}; hooker(this);" data-enabled="true" data-id="pp-block-1" data-injected="true"></btn></div></html>